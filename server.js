require('dotenv').config(); // Load bi·∫øn m√¥i tr∆∞·ªùng t·ª´ .env
const express = require('express');
const axios = require('axios');
const fs = require('fs');
const fsPromises = require('fs').promises; // S·ª≠ d·ª•ng fs.promises cho async/await
const path = require('path');
const crypto = require('crypto');
const os = require('os'); // << Th√™m module os ƒë·ªÉ l·∫•y IP LAN
const chalk = require('chalk');
const notifier = require('node-notifier');
const {
  GoogleGenAI
} = require("@google/genai");

const app = express();
const port = process.env.PORT || 3000; // S·ª≠ d·ª•ng c·ªïng t·ª´ env ho·∫∑c m·∫∑c ƒë·ªãnh 3000

// Middleware ƒë·ªÉ parse JSON request body
app.use(express.json());

// Th·ªëng k√™
let stats = {
    success: 0,
    failed: 0
};

// H√†m c·∫≠p nh·∫≠t ti√™u ƒë·ªÅ console
function updateConsoleTitle() {
    process.title = `Gemini Audio API | Success: ${stats.success} | Failed: ${stats.failed}`;
}

// H√†m hi·ªÉn th·ªã th√¥ng b√°o Windows
function showNotification(title, message) {
    notifier.notify({
        title: title,
        message: message,
        icon: path.join(__dirname, 'icon.png'),
        sound: true
    });
}

// --- C·∫•u h√¨nh Gemini ---
// L·∫•y t·∫•t c·∫£ API keys t·ª´ .env
const getGeminiApiKeys = () => {
    const keys = [];
    let i = 1;
    while (process.env[`GEMINI_API_KEY_${i}`]) {
        keys.push(process.env[`GEMINI_API_KEY_${i}`]);
        i++;
    }
    return keys;
};

const GEMINI_API_KEYS = getGeminiApiKeys();
if (GEMINI_API_KEYS.length === 0) {
    console.error("‚ùå L·ªói: Vui l√≤ng ƒë·∫∑t √≠t nh·∫•t m·ªôt bi·∫øn m√¥i tr∆∞·ªùng GEMINI_API_KEY_1 trong file .env");
    process.exit(1);
}

// H√†m l·∫•y random API key
const getRandomApiKey = () => {
    const randomIndex = Math.floor(Math.random() * GEMINI_API_KEYS.length);
    return GEMINI_API_KEYS[randomIndex];
};

// Kh·ªüi t·∫°o Gemini client v·ªõi API key m·ªõi m·ªói l·∫ßn g·ªçi
const getGeminiClient = () => {
    const apiKey = getRandomApiKey();
    console.log(`S·ª≠ d·ª•ng API Key: ${apiKey.substring(0, 10)}...`);
    return new GoogleGenAI({ apiKey });
};

// --- Th∆∞ m·ª•c t·∫°m ---
const TEMP_DIR = path.join(__dirname, 'temp_audio');

// --- H√†m ti·ªán √≠ch ---

// H√†m t·∫£i file t·ª´ URL v√† l∆∞u v√†o th∆∞ m·ª•c t·∫°m
async function downloadFile(url, filePath) {
    try {
        const response = await axios({
            method: 'GET',
            url: url,
            responseType: 'stream',
            timeout: 10000, // Th√™m timeout 10 gi√¢y
            validateStatus: function (status) {
                return status >= 200 && status < 300; // Ch·ªâ ch·∫•p nh·∫≠n status 2xx
            }
        });
        const mimeType = response.headers['content-type'] || 'audio/mpeg';
        await fsPromises.mkdir(path.dirname(filePath), { recursive: true });
        const writer = fs.createWriteStream(filePath);
        response.data.pipe(writer);
        return new Promise((resolve, reject) => {
            writer.on('finish', () => resolve({ filePath, mimeType }));
            writer.on('error', (err) => {
                fs.unlink(filePath, () => {});
                console.error("L·ªói khi ghi file:", err);
                reject(new Error(`Kh√¥ng th·ªÉ ghi file t·∫£i v·ªÅ: ${err.message}`));
            });
             response.data.on('error', (err) => {
                writer.close();
                fs.unlink(filePath, () => {});
                console.error("L·ªói khi t·∫£i stream:", err);
                reject(new Error(`L·ªói khi t·∫£i file t·ª´ URL: ${err.message}`));
            });
        });
    } catch (error) {
        if (axios.isAxiosError(error)) {
            console.error(`L·ªói Axios khi t·∫£i ${url}:`, error.response?.status, error.message);
            throw new Error(`Kh√¥ng th·ªÉ t·∫£i file t·ª´ URL (status: ${error.response?.status || 'N/A'})`);
        } else {
            console.error(`L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫£i ${url}:`, error);
            throw new Error(`L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫£i file: ${error.message}`);
        }
    }
}

// H√†m ƒë·ªçc file v√† chuy·ªÉn sang base64
async function readFileAsBase64(filePath) {
    try {
        console.log(`ƒêang ƒë·ªçc file: ${filePath}`);
        const data = await fsPromises.readFile(filePath, { encoding: 'base64' });
        return data;
    } catch (error) {
        console.error("\nL·ªói khi ƒë·ªçc file:", error);
        throw new Error(`Kh√¥ng th·ªÉ ƒë·ªçc file: ${error.message}`);
    }
}

function getLanIp() {
    const nets = os.networkInterfaces();
    for (const name of Object.keys(nets)) {
        for (const net of nets[name]) {
            if (net.family === 'IPv4' && !net.internal) {
                return net.address;
            }
        }
    }
    return null;
}

async function getPublicIp() {
    try {
        const response = await axios.get('https://icanhazip.com');
        return response.data.trim();
    } catch (error) {
        console.warn("Kh√¥ng th·ªÉ l·∫•y ƒë·ªãa ch·ªâ IP Public:", error.message);
        return null;
    }
}

// --- ƒê·ªãnh nghƒ©a API Endpoint ---
app.post('/audio', async (req, res) => {
    const { url, title: userProvidedTitle } = req.body;
    let tempFilePath = null;

    // --- 1. Validation ---
    if (!url || !userProvidedTitle) {
        return res.status(400).json({ status: false, error: 'Thi·∫øu tham s·ªë `url` ho·∫∑c `title` trong request body.' });
    }
    try {
        new URL(url);
    } catch (e) {
        return res.status(400).json({ status: false, error: 'URL kh√¥ng h·ª£p l·ªá.' });
    }

    // Log v·ªõi title ng∆∞·ªùi d√πng cung c·∫•p
    console.log(chalk.cyan('\n' + '='.repeat(50)));
    console.log(chalk.yellow('üì¢ Y√™u c·∫ßu m·ªõi'));
    console.log(chalk.gray('URL:'), chalk.white(url));
    console.log(chalk.gray('Title:'), chalk.white(userProvidedTitle));

    try {
        // --- 2. T·∫°o t√™n file ng·∫´u nhi√™n ---
        const urlParts = new URL(url);
        const extension = path.extname(urlParts.pathname) || '.mp3';
        const randomFileName = `${crypto.randomUUID()}${extension}`;
        tempFilePath = path.join(TEMP_DIR, randomFileName);
        console.log(chalk.gray('File t·∫°m:'), chalk.white(tempFilePath));

        // --- 3. T·∫£i file v·ªÅ ---
        console.log(chalk.blue('‚¨áÔ∏è  ƒêang t·∫£i file...'));
        const { mimeType } = await downloadFile(url, tempFilePath);
        console.log(chalk.green('‚úÖ T·∫£i file th√†nh c√¥ng'), chalk.gray(`(MIME: ${mimeType})`));

        // --- 4. ƒê·ªçc file v√† chuy·ªÉn sang base64 ---
        console.log(chalk.blue('üìñ ƒêang ƒë·ªçc file...'));
        const base64Data = await readFileAsBase64(tempFilePath);

        // --- 5. H·ªèi Gemini ---
        console.log(chalk.blue('ü§ñ ƒêang gi·∫£i captcha...'));
        const fullPromptTitle = `Audio Challenge: ${userProvidedTitle}`;

        const contents = [
            { text: fullPromptTitle },
            {
                inlineData: {
                    mimeType: mimeType,
                    data: base64Data
                }
            }
        ];

        // S·ª≠ d·ª•ng API key m·ªõi cho m·ªói request
        const genAI = getGeminiClient();
        const result = await genAI.models.generateContent({
            model: "gemini-2.0-flash",
            contents: contents
        });

        // --- 6. X·ª≠ l√Ω k·∫øt qu·∫£ t·ª´ Gemini ---
        if (!result || !result.candidates || result.candidates.length === 0) {
            throw new Error(`Gemini kh√¥ng tr·∫£ v·ªÅ k·∫øt qu·∫£.`);
        }

        const geminiResponseText = result.candidates[0].content.parts
            .map(part => part.text)
            .join("");

        if (!geminiResponseText) {
            throw new Error(`Gemini tr·∫£ v·ªÅ k·∫øt qu·∫£ r·ªóng.`);
        }

        // X√≥a c√°c k√Ω t·ª± \n trong k·∫øt qu·∫£
        const cleanResponse = geminiResponseText.replace(/\n/g, '').trim();

        // C·∫≠p nh·∫≠t th·ªëng k√™
        stats.success++;
        updateConsoleTitle();

        // Hi·ªÉn th·ªã k·∫øt qu·∫£
        console.log(chalk.green('‚ú® K·∫øt qu·∫£:'), chalk.white(cleanResponse));
        console.log(chalk.cyan('='.repeat(50)));

        // --- 7. G·ª≠i k·∫øt qu·∫£ v·ªÅ cho client ---
        res.status(200).json({ status: true, result: cleanResponse });

    } catch (error) {
        // C·∫≠p nh·∫≠t th·ªëng k√™
        stats.failed++;
        updateConsoleTitle();

        // Log l·ªói
        console.error(chalk.red('\n‚ùå L·ªói:'), chalk.white(error.message));
        console.log(chalk.cyan('='.repeat(50)));

        // Hi·ªÉn th·ªã th√¥ng b√°o Windows
        showNotification('Gemini Audio API Error', error.message);

        res.status(500).json({ status: false, error: error.message });
    } finally {
        // --- 8. X√≥a file t·∫°m (lu√¥n th·ª±c hi·ªán) ---
        if (tempFilePath) {
            try {
                await fsPromises.unlink(tempFilePath);
            } catch (cleanupError) {
                console.log(chalk.yellow('‚ö†Ô∏è  Kh√¥ng th·ªÉ x√≥a file t·∫°m:'), chalk.white(cleanupError.message));
            }
        }
    }
});

// --- Kh·ªüi ƒë·ªông Server (s·ª≠ d·ª•ng async IIFE) ---
(async () => {
    try {
        // ƒê·∫£m b·∫£o th∆∞ m·ª•c t·∫°m t·ªìn t·∫°i
        await fsPromises.mkdir(TEMP_DIR, { recursive: true });
        console.log(chalk.green('üìÅ Th∆∞ m·ª•c t·∫°m:'), chalk.white(TEMP_DIR));

        const lanIp = getLanIp();
        const publicIp = await getPublicIp();

        app.listen(port, () => {
            console.log(chalk.cyan('\n' + '='.repeat(50)));
            console.log(chalk.green('üöÄ Gemini Audio API ƒëang ch·∫°y!'));
            console.log(chalk.gray('Localhost:'), chalk.white(`http://localhost:${port}/audio`));
            if (lanIp) {
                console.log(chalk.gray('M·∫°ng LAN:'), chalk.white(`http://${lanIp}:${port}/audio`));
            }
            if (publicIp) {
                console.log(chalk.gray('Public:'), chalk.white(`http://${publicIp}:${port}/audio`));
            }
            console.log(chalk.cyan('='.repeat(50)));
            
            // Th√™m v√≠ d·ª• payload JSON
            console.log(chalk.yellow('\nüìù V√≠ d·ª• payload JSON:'));
            console.log(chalk.white(JSON.stringify({
                url: "https://example.com/audio.mp3",
                title: "Gi·∫£i captcha √¢m thanh"
            }, null, 2)));
            
            console.log(chalk.cyan('='.repeat(50)));
            console.log(chalk.yellow('üëÇ ƒêang ch·ªù y√™u c·∫ßu...\n'));

            // C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ console ban ƒë·∫ßu
            updateConsoleTitle();
        });

    } catch (err) {
        console.error(chalk.red('‚ùå L·ªói nghi√™m tr·ªçng khi kh·ªüi ƒë·ªông server:'), chalk.white(err.message));
        if (err.code === 'EADDRINUSE') {
            console.error(chalk.yellow('   G·ª£i √Ω: C·ªïng c√≥ th·ªÉ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ·ª©ng d·ª•ng kh√°c.'));
        }
        process.exit(1);
    }
})();